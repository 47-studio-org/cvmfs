
CVMFS_TEST_DEBUGLOG=
CVMFS_TEST_PROXY=${CVMFS_TEST_PROXY:=http://ca-proxy.cern.ch:3128}
CVMFS_TEST_SCRATCH=${CVMFS_TEST_SCRATCH:=/tmp/cvmfs-test}
CVMFS_TEST_EXCLUDE=${CVMFS_TEST_EXCLUDE:=}

CVMFS_TEST_REPO=test.cern.ch
CVMFS_TEST_USER=sftnight
CVMFS_TEST_GROUP=sftnight

CVMFS_TEST_DEBUG=

cvmfs_clean() {
  sudo cvmfs_config umount > /dev/null || return 100
  sudo rm -rf /var/lib/cvmfs/*
  sudo rm -f /etc/cvmfs/default.local
  sudo rm -f /etc/cvmfs/config.d/*
  
  timeout=5
  while $(pgrep -u cvmfs cvmfs2 > /dev/null); do
    if [ $timeout -eq 0 ]; then
      return 101
    fi
    timeout=$(($timeout-1))
    sleep 1
  done

  return 0
}


cvmfs_mount() {
  repositories=$1

  sudo sh -c "echo \"CVMFS_REPOSITORIES=$repositories\" > /etc/cvmfs/default.local" || return 100
  sudo sh -c "echo \"CVMFS_HTTP_PROXY=${CVMFS_TEST_PROXY}\" >> /etc/cvmfs/default.local" || return 100
  sudo sh -c 'echo "CVMFS_TIMEOUT=20" >> /etc/cvmfs/default.local' || return 100
  sudo sh -c 'echo "CVMFS_TIMEOUT_DIRECT=20" >> /etc/cvmfs/default.local' || return 100
  sudo sh -c 'echo "CVMFS_SERVER_URL=http://cvmfs-atlas-nightlies.cern.ch/cvmfs/atlas-nightlies.cern.ch" > /etc/cvmfs/config.d/atlas-nightlies.cern.ch.local' || return 100
  if [ "x$CVMFS_TEST_DEBUGLOG" != "x" ]; then
    sudo sh -c "echo \"CVMFS_DEBUGLOG=$CVMFS_TEST_DEBUGLOG\" >> /etc/cvmfs/default.local" || return 100
  fi
  cvmfs_config probe > /dev/null 2>&1 || return 101
  
  return 0
}


cvmfs_umount() {
  repositories=$1

  for r in $(echo $repositories | tr , " "); do
    sudo umount /cvmfs/$r || return 100

    timeout=5
    while cat /proc/mounts | grep -q /cvmfs/$r; do
      if [ $timeout -eq 0 ]; then
        return 101
      fi
      timeout=$(($timeout-1))
      sleep 1
    done
  done

  return 0
}



get_cvmfs_cachedir() {
  repository=$1

  local cache_dir
  cache_dir=$(cvmfs_config showconfig $repository | grep CVMFS_CACHE_DIR | awk '{print $1}' | cut -d= -f2)
  if [ "x$cache_dir" = "x" ]; then
    echo "Failed to figure out cache directory"
    exit 1
  fi
  echo $cache_dir
}


check_time() {
  start_time=$1
  end_time=$2
  limit=$3

  diff_time=$(($end_time-$start_time))

  if [ $diff_time -gt $limit ]; then
    echo "Time limit exceeded" >&2
    return 100
  fi
  
  return 0
}


check_memory() {
  instance=$1
  limit=$2

  pid=$(attr -qg pid /cvmfs/$instance) || return 100
  rss=$(sudo cat /proc/$pid/status | grep VmRSS | awk '{print $2}') || return 101

  if [ $rss -gt $limit ]; then
    echo "Memory limit exceeded" >&2
    return 102
  fi

  return 0
}


create_repo() {
  repo=$1
  uid=$2

  if [ `cvmfs_server list | grep $repo | wc -l` -ne 0 ]; then
    echo "Repository $repo is already present... removing it"
    echo "y" | sudo cvmfs_server rmfs $repo || return 100
  fi

  echo "Creating new repository $repo..."
  sudo cvmfs_server mkfs $repo -o $uid || return 101
}


create_empty_repo() {
  repo=$1
  uid=$2

  # check if someone tries to go upwards in the directory tree to safeguard
  # harmful things might happen with `rm -fR *` :o)
  if [ x"$repo" != x`echo $repo | sed -e 's/\/\.\.//' -e 's/\.\.\///' -e 's/\.\.//'` ];
  then
    return 100
  fi

  create_repo $repo $uid || return 101

  sudo cvmfs_server transaction $repo || return 102
  rm -fR /cvmfs/$repo/new_repository
  sudo cvmfs_server publish $repo || return 103
}


# generate a custom style recursive listing with only the following infos:
# - file name
# - linkcount
# - file mode
# - file size
# - parent directory
# - symlink destination (when applicable)
# - uid and gid can be specified
#
# @param directory          the directory to be listed
# @param uid                specify a UID for the file owner (optional)
# @param gid                specify a GID for the file owner (optional)
# @return                   a custom directory listing
create_listing()
{
  directory=$1
  uid=$2
  gid=$3

  lst=`ls --almost-all --recursive -l --file-type --time-style=+ $directory | \
  awk '
  {
    # skipt the tatal file count, ls prints at the end of each directory listing
    if(substr($1, 0, 5) == "total") next;

    # length of base directory path
    base_dir_length = length(base_dir)

    # truncate base path from the path printed before each new listing
    if(substr($0, 0, base_dir_length) == base_dir) {
      print substr($0, base_dir_length + 1, length($0)-1)
      next;
    }

    # first character
    first = substr($0, 0, 1);

    # print file meta information
    # $1    => file mode (rwx bits, ...)
    # $2    => linkcount
    # $3,$4 => owner, group (might also be provided from outside)
    # $5    => file size (skipped for directories)
    # $6    => file name
    # $7,$8 => symlink destination (only for symlinks :o) )

    if (first != "-" && first != "d" && first != "l")
    {
      printf "\n"
      next;
    }

    # print out file information
    printf $1                     " ";
    printf $2                     " ";
    printf (uid == "" ? $3 : uid) " ";
    printf (gid == "" ? $4 : gid) " ";
    printf $6;

    if(first == "l") printf " " $7 " " $8;
    if(first != "d") printf " " $5;
    printf "\n"
  }' uid=$uid gid=$gid base_dir=$directory`

  echo -e "$lst"
}

# compares the file contents and file meta data of two directories
# Note: function creates the files 'listingFile1' and 'listingFile2' in `pwd`
#       `pwd` should NOT be part of the comparison!!
#
# @param dir1    the directory to probe
# @param dir2    the ground truth directory
# @return        != 0 to indicate inequality, 0 means success
compare_directories()
{
  dir1=$1
  dir2=$2

  listing1=`create_listing $dir1`
  listing2=`create_listing $dir2`

  echo "check if directory structure and file meta data fits"
  echo -e "$listing1" > listingFile1
  echo -e "$listing2" > listingFile2
  diff -uN listingFile1 listingFile2 2>&1 || return 101

  echo "check if the file contents in both directories are the same"
  diff -ruN $dir1 $dir2 2>&1 || return 102

  return 0
}

# uses `cvmfs_server check` to check the integrity of the catalog structure
# @param repo    the repository to be checked
check_catalogs()
{
  repo=$1
  cvmfs_server check $repo
}

# wrapper function to start a new repository update transaction
# @param repo    the repository you want to start the transaction for
start_transaction()
{
  repo=$1
  cvmfs_server transaction $repo
}

# wrapper function to publish an repository after its contents were updated.
# @param repo    the repository name to start the transaction in
publish_repo()
{
  repo=$1

  # enable the debug mode?
  # in debug mode we redirect output directly to the interactive shell,
  # overriding any redirections to logfiles or whatever... We want to hack!
  case $CVMFS_TEST_DEBUG in
    fail)
      cvmfs_server publish $repo -d > /dev/tty 2>&1
    ;;
    startup)
      cvmfs_server publish $repo -D > /dev/tty 2>&1
    ;;
    *)
      cvmfs_server publish $repo
    ;;
  esac
}
